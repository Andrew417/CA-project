|  ID |  Mode | Category                           | Purpose (Requirement)                                              | Stimulus (Deterministic Sequence)                                                                                                                                                                                                                                                                                                                                                         | Self-Checks / Assertions                                                                                                                                                                                  |
| --: | :---: | ---------------------------------- | ------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|  T1 | WT/WB | Reset                              | Clean init + first access miss                                     | `rst=1` (≥1 clk) → `rst=0`; `READ A` where `A=0x0010`                                                                                                                                                                                                                                                                                                                                     | `done` pulses; `readData==0` (because RAM init); `cycles_to_done` = miss latency (store as `MISS_LAT`)                                                                                                    |
|  T2 | WT/WB | Read Miss                          | Miss fetch from RAM + cache fill                                   | Preload `RAM[A]=D1`; then `READ A`                                                                                                                                                                                                                                                                                                                                                        | `readData==D1`; `cycles_to_done == MISS_LAT`                                                                                                                                                              |
|  T3 | WT/WB | Read Hit                           | Hit returns cached data                                            | `READ A` again                                                                                                                                                                                                                                                                                                                                                                            | `readData==D1`; `cycles_to_done < MISS_LAT` (store as `HIT_LAT`)                                                                                                                                          |
|  T4 |   WT  | Write Hit                          | Mandatory write-through on hit                                     | Ensure `A` cached (T2/T3). Do `WRITE A=D2`; then `READ A`                                                                                                                                                                                                                                                                                                                                 | `READ` returns `D2` and is a hit; additionally assert RAM updated: either hierarchical check `RAM[A]==D2` OR evict A (see T8) then reread `A` returns `D2`                                                |
|  T5 |   WT  | Write Miss                         | Mandatory write-through on miss + (your design) write-allocate     | Pick `B` new address (not yet touched), e.g. `B=0x0020`. Do `WRITE B=D3`; then `READ B`                                                                                                                                                                                                                                                                                                   | `READ B==D3`; should be hit latency (`cycles_to_done==HIT_LAT`); RAM check: `RAM[B]==D3` (hierarchical or evict then reread)                                                                              |
|  T6 | WT/WB | Different Sets                     | Index decode correctness                                           | Choose `C=A+1` (different set). Preload `RAM[C]=D4`. Do `READ C`, then `READ A`                                                                                                                                                                                                                                                                                                           | `READ C==D4` (miss then fill). `READ A==D1/D2` remains correct; no cross-set corruption                                                                                                                   |
|  T7 | WT/WB | Same Set Fill (4 ways)             | Mandatory: check all ways; associativity                           | Choose set base `S=3`. Addresses: `S0=S`, `S1=S+64`, `S2=S+128`, `S3=S+192`. Preload RAM for each with `V0..V3`. Then `READ S0,S1,S2,S3` (each once). Then `READ S0..S3` again.                                                                                                                                                                                                           | First round: all return `Vx` with miss latency. Second round: all return `Vx` with hit latency. Confirms 4-way behavior                                                                                   |
|  T8 | WT/WB | Replacement (Deterministic Victim) | Mandatory replacement + prepares LRU tests                         | Using same set from T7, make victim deterministic: After fills, “protect” three lines by hitting them: `READ S1`, `READ S2`, `READ S3` (in this order). Do **not** touch `S0`. Then access new `S4=S+256` (preload `RAM[S4]=V4`, then `READ S4`). Finally `READ S0` and `READ S1`                                                                                                         | Expect `S4` returns `V4`. Expect `S0` is **evicted** (miss latency on `READ S0`, returns `V0`). Expect `S1` still hit and returns `V1`. (This validates replacement behavior and sets up LRU correctness) |
|  T9 | WT/WB | Read-after-Write (RAW)             | Data correctness after write                                       | Pick `X=0x0100`. Preload `RAM[X]=0`. Do `WRITE X=D5`; immediately `READ X`                                                                                                                                                                                                                                                                                                                | `READ X==D5` (hit latency due to write-allocate)                                                                                                                                                          |
| T10 | WT/WB | Handshake                          | Mandatory: ready/done protocol                                     | For N random ops: only start when `ready==1`. Never start when `ready==0`.                                                                                                                                                                                                                                                                                                                | Assert `done` pulses exactly once per request; no deadlock; `ready` returns to 1 after done                                                                                                               |
| T11 | WT/WB | Address Limits                     | Mandatory: address width correctness                               | Use `A0=0`, `Amax=16'hFFFF`. Preload `RAM[A0]=D6`, `RAM[Amax]=D7`. Then `READ A0`, `READ Amax`, then repeat reads                                                                                                                                                                                                                                                                         | Correct data; first accesses miss latency, repeats hit latency; no out-of-range/unknown behavior                                                                                                          |
| T12 |   WB  | Write-Back Dirty Evict             | Bonus: dirty victim written back on eviction                       | Set `WRITE_BACK=1`. Choose set `S=5`: `S0=S`, `S1=S+64`, `S2=S+128`, `S3=S+192`, `S4=S+256`. Preload RAM: all 0. Fill set by reading S0..S3. Then `WRITE S0=D8` (makes S0 dirty). Make S0 LRU by hitting others: `READ S1,S2,S3`. Preload `RAM[S4]=0x1111`. Then `READ S4` to evict S0. Finally check RAM: `RAM[S0]==D8` (hierarchical) OR reread after eviction: `READ S0` returns `D8`. | Must observe data preserved. If you use hierarchical RAM check, assert `dut.ram_inst.mem[S0]==D8` after eviction.                                                                                         |
| T13 |   WB  | Write-Back Clean Evict             | Bonus: no WB when line is clean                                    | In WB mode, pick set `S=6`. Preload `RAM[S0]=D9`. Do `READ S0` (fills clean). Fill rest and evict S0 without ever writing it.                                                                                                                                                                                                                                                             | After eviction, RAM remains `D9`. Reread returns `D9`. (Optional: hierarchical check no unintended change)                                                                                                |
| T14 |   WB  | Write Miss Dirty then Evict        | Bonus: write-miss creates dirty line; RAM updated only on eviction | In WB mode, pick `Y=0x0200`, same set pattern to force eviction later. Do `WRITE Y=DA` (miss→allocate dirty). Immediately check RAM **not updated yet** (hierarchical `RAM[Y]!=DA` if it was 0). Then force eviction of Y by filling its set + inserting 5th. After eviction, check `RAM[Y]==DA`.                                                                                         | Confirms “write-back, not write-through” behavior in WB mode                                                                                                                                              |
| T15 |   WT  | Confirm WT always updates RAM      | Mandatory: WT mode behavior contrasted with WB                     | In WT mode, do `WRITE Z=DB` (any addr). Immediately check `RAM[Z]==DB` (hierarchical).                                                                                                                                                                                                                                                                                                    | Confirms WT property explicitly                                                                                                                                                                           |
